(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{479:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"对ssr的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对ssr的理解"}},[t._v("#")]),t._v(" 对SSR的理解")]),t._v(" "),a("p",[t._v("SSR页就是服务端渲染,也就是将Vue客户端把渲染成HTML的工作放在服务端完成,然后再把html直接返回给客户端")]),t._v(" "),a("p",[t._v("SSR的优势:")]),t._v(" "),a("ul",[a("li",[t._v("更好的SEO")]),t._v(" "),a("li",[t._v("首屏加载速度更快")])]),t._v(" "),a("p",[t._v("SSR的缺点")]),t._v(" "),a("ul",[a("li",[t._v("开发条件会受到限制,服务器端渲染只支持beforeCreate和create两个钩子;")]),t._v(" "),a("li",[t._v("当需要一些外部扩展库时需要特殊处理,服务端渲染应用程序也需要处于NODE.js环境;")]),t._v(" "),a("li",[t._v("更多的服务端负载.")])]),t._v(" "),a("h2",{attrs:{id:"vue的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的优点"}},[t._v("#")]),t._v(" Vue的优点")]),t._v(" "),a("ul",[a("li",[t._v("轻量级框架:只关注视图层,是一个构建数据的视图合集,大小只有几十"),a("code",[t._v("kb")])]),t._v(" "),a("li",[t._v("简单易学:国人开发,中文文档,不存在语言障碍,易于理解和学习;")]),t._v(" "),a("li",[t._v("双向数据绑定:保留"),a("code",[t._v("angular")]),t._v("的特点,在数据操作方面更简单;")]),t._v(" "),a("li",[t._v("组件化:保留了"),a("code",[t._v("react")]),t._v("的优点,实现了"),a("code",[t._v("html")]),t._v("的封装和重用,在构建但页面应用方面有着独特的优势;")]),t._v(" "),a("li",[t._v("视图,数据,结构分离:使数据的更改更简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作;")]),t._v(" "),a("li",[t._v("虚拟DOM:"),a("code",[t._v("dom")]),t._v("操作是非常耗费性能的,不再使用原生的"),a("code",[t._v("dom")]),t._v("操作节点,极大解放"),a("code",[t._v("dom")]),t._v("操作,但具体操作的还是"),a("code",[t._v("dom")]),t._v("不过是换了另一种方式;")]),t._v(" "),a("li",[t._v("运行速度更快:相比较于"),a("code",[t._v("react")]),t._v("而言,同样是操作虚拟"),a("code",[t._v("dom")]),t._v(",就性能而言,"),a("code",[t._v("vue")]),t._v("存在很大的优势.")])]),t._v(" "),a("h2",{attrs:{id:"computed的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed的实现原理"}},[t._v("#")]),t._v(" computed的实现原理")]),t._v(" "),a("ol",[a("li",[t._v("computed 本质是一个惰性求值的观察者")]),t._v(" "),a("li",[t._v("computed 内部实现了一个惰性的watcher,也就是computed watcher,computed watcher 不会立刻求值,同时持有一个dep示例.")]),t._v(" "),a("li",[t._v("其内部通过this.dirty属性标记计算属性是否需要重新求值.")]),t._v(" "),a("li",[t._v("当computed的依赖状态发生改变时,就会通知这个惰性的watcher,computed watcher通过 this.dep.subs.length判断有没有订阅者,")]),t._v(" "),a("li",[t._v("有的话,会重新计算,然后对比新旧值,如果变化了,才会重新渲染,(Vue想确保不仅仅是计算属性依赖的值发生变化,而是当计算属性最终计算的值发生变化时才会触发渲染watcher重新渲染,本质上是一种优化.)")]),t._v(" "),a("li",[t._v("没有的话,仅仅把this.dirty = true.(当计算属性依赖于其他数据时,属性并不会立即重新计算,只有之后其他地方需要读取属性的时候,他才会真正的计算,寄具备lazy(懒计算)特性.)")])]),t._v(" "),a("h2",{attrs:{id:"能说下vue-router中常用的hash和history路由模式的实现原理吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#能说下vue-router中常用的hash和history路由模式的实现原理吗"}},[t._v("#")]),t._v(" 能说下vue-router中常用的hash和history路由模式的实现原理吗?")]),t._v(" "),a("ol",[a("li",[t._v("hash模式的实现原理\n早期的前端路由实现就是基于localhost.hash来实现的,其实现原理很简单,localhost.hash的值就是URL中#后面的内容.比如"),a("code",[t._v("https://www.baidu.com#search")]),t._v(",它的localhost.hash的值为‘#search’\nhash路由模式的实现主要是基于下面几个特性:\n"),a("ul",[a("li",[t._v("URL中的hash值只是客户端的一种状态,也就是说当向服务器端发出请求时,hash部分不会被发送;hash值的改变,都会在浏览器的访问历史中增加一个记录,因此我们能通过浏览器的回退、前进按钮控制hash的切换‘")]),t._v(" "),a("li",[t._v("可以通过a标签,并设置href属性,当用户点击这个表亲啊后,URL的hash值会发生改变;或者使用javascript来对localhost.hash进行赋值,改变URL的hash值;")]),t._v(" "),a("li",[t._v("我们可以使用hashchange事件来监听hash的变化,从而对页面进行跳转(渲染);")])])]),t._v(" "),a("li",[t._v("history模式的实现原理\nHTML5提供了Histoty API来实现URL的变化,其中最主要的两个API有以下两个: history.pushState()和"),a("code",[t._v("history.replaceState()")]),t._v(".这两个API可以在不进行刷新的情况下,操作浏览器的历史记录.唯一不同的时,前者是增加一个历史记录,后者是直接替换当前的历史记录,如下所示:"),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pushState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nwindow"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("repalceState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),t._v("history 路由模式的实现主要基于存在下面几个特性:\n"),a("ul",[a("li",[t._v("pushState 和replaceState 两个API来操作实现URL的变化;")]),t._v(" "),a("li",[t._v("我们可以使用popstate事件来监听url的变化,从而对页面进行跳转(渲染);")]),t._v(" "),a("li",[t._v("history.pushState()或history.replaceState()不会出发popstate事件,这时候我们需要手动触发页面跳转(渲染);\n"),a("br"),t._v("\n参考:"),a("a",{attrs:{href:"https://kc7474.com/archives/1333?url=vue",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端vue面试题详细解答"),a("OutboundLink")],1)])])])]),t._v(" "),a("h2",{attrs:{id:"对react和vue的理解-它们的异同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对react和vue的理解-它们的异同"}},[t._v("#")]),t._v(" 对React和Vue的理解,它们的异同")]),t._v(" "),a("ul",[a("li",[t._v("相似之处:\n"),a("ul",[a("li",[t._v("都将注意力集中保持在核心库,而将其他功能如路由和全局状态管理相关的库;")]),t._v(" "),a("li",[t._v("都有自己的构建工具,能让你得到一个根据最佳实践设置的项目模版;")]),t._v(" "),a("li",[t._v("都使用了virtual DOM (虚拟DOM)提高重绘性能;")]),t._v(" "),a("li",[t._v("都有props的概念,允许组件间的数据传递;")]),t._v(" "),a("li",[t._v("都鼓励组件化应用,将应用分拆成一个个功能明确的模块,提高复用性;.")])])]),t._v(" "),a("li",[t._v("不同之处:\n"),a("ol",[a("li",[a("p",[t._v("数据流\nVue默认支持数据双向绑定,而React一直提倡单向数据流")])]),t._v(" "),a("li",[a("p",[t._v("虚拟DOM\n"),a("br"),t._v("\nVue2.x开始引入‘Virtual DOM’,消除了和React在这方面的差异,但是在具体的细节还是有各自的特点.")]),t._v(" "),a("ul",[a("li",[t._v("Vue宣称可以更快的计算出 Virtual DOM的差异,这是由于它在渲染过程中,会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.")]),t._v(" "),a("li",[t._v("对于React而言,每当应用的状态被改变时,全部自组件都会重新渲染.当前,这可以通过PureComponent/shouldComponentUpdate这个生命周期方法来进行控制,但Vue将此视为默认的优化.")])])]),t._v(" "),a("li",[a("p",[t._v("组件化\n"),a("br"),t._v("\nReact与Vue最大的不同是模版的编写.")]),t._v(" "),a("ul",[a("li",[t._v("Vue鼓励写近似常规的html模版,写起来很接近标准html元素,只是多写了一些属性.")]),t._v(" "),a("li",[t._v("React推荐你所有的模版通用Javascript的语法扩展——JSX书写.\n"),a("br"),t._v("\n具体来讲:React中的rrender函数是支持闭包特性的,所以import的组件在render中可以直接调用.但是在Vue中,由于模版中使用的数据都必须在this上进行一次中转,所以import一个组建完了之后,还需要在components中在声明下.")])])]),t._v(" "),a("li",[a("p",[t._v("监听数据变化的实现原理不同")]),t._v(" "),a("ul",[a("li",[t._v("Vue 通过getter/setter以及一些函数的劫持,能精确知道数据变化,不需要特变的优化就能达到很好的性能.")]),t._v(" "),a("li",[t._v("React默认时通过比较引用的方式进行的,如果不优化(pureComponents/shouldComponentUpdate)可能导致大量不必要的DOM的重新渲染.这是因为Vue使用的是可变数据,而React更强调数据的不可变.")])])]),t._v(" "),a("li",[a("p",[t._v("高阶组件\nReact可以通过高阶组件(HOC)来扩展,而Vue需要通过mixins来扩展.")]),t._v(" "),a("p",[t._v("高阶组件就是高阶函数,而React的组件本身就是纯粹的函数,所以高阶函数对React来说易如反掌.相反Vue.js使用HTML模版创建视图组件,这时模版无法有效的变异,因此Vue不能采用HOC来实现.")])]),t._v(" "),a("li",[a("p",[t._v("构建工具\n两者都有自己的构建工具:")]),t._v(" "),a("ul",[a("li",[t._v("React==> Create React APP")]),t._v(" "),a("li",[t._v("Vue ==> vue-cli")])])]),t._v(" "),a("li",[a("p",[t._v("跨平台")]),t._v(" "),a("ul",[a("li",[t._v("React ==> React Native")]),t._v(" "),a("li",[t._v("Vue ==> Weex")])])])])])]),t._v(" "),a("h2",{attrs:{id:"vue-的生命周期方法有哪些-一般在哪一步发请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的生命周期方法有哪些-一般在哪一步发请求"}},[t._v("#")]),t._v(" Vue 的生命周期方法有哪些 一般在哪一步发请求")]),t._v(" "),a("h3",{attrs:{id:"beforecreate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforecreate"}},[t._v("#")]),t._v(" beforeCreate")]),t._v(" "),a("ul",[a("li",[t._v("是在实例初始化之后,数据观测(data observer)和event/watcher 事件配置之前被调用.")]),t._v(" "),a("li",[t._v("在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问.")])]),t._v(" "),a("h3",{attrs:{id:"created"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#created"}},[t._v("#")]),t._v(" created")]),t._v(" "),a("ul",[a("li",[t._v("实例已经创建完成之后被调用.")]),t._v(" "),a("li",[t._v("在这一步,实例已经完以下的配置:数据观测(data observer),属性和方法的运算,watch/event事件回调,这里没有$el,如果非想要与DOM交互,可以通过vm.$nextTick来访问DOM.")])]),t._v(" "),a("h3",{attrs:{id:"befeoremounted"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#befeoremounted"}},[t._v("#")]),t._v(" befeoreMounted")]),t._v(" "),a("ul",[a("li",[t._v("在挂载之前被调用:相关的render函数首次被调用.")])]),t._v(" "),a("h3",{attrs:{id:"mounted"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mounted"}},[t._v("#")]),t._v(" mounted")]),t._v(" "),a("ul",[a("li",[t._v("在挂载完成后发生,在当前阶段,真实的DOM挂载完毕,数据完成双向绑定,可以访问到DOM节点.")])]),t._v(" "),a("h3",{attrs:{id:"beforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforeupdate"}},[t._v("#")]),t._v(" beforeUpdate")]),t._v(" "),a("ul",[a("li",[t._v("数据更新时调用,发生在虚拟DOM重新渲染和打补丁(patch)之前.可以在这个狗子中进一步的更改状态,这不会出发附加的重新渲染过程")])]),t._v(" "),a("h3",{attrs:{id:"updated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updated"}},[t._v("#")]),t._v(" updated")]),t._v(" "),a("ul",[a("li",[t._v("发生在更新完成之后,当前阶段组件DOM已完成更新.要注意的是避免在此期间更改数据,因为这可能会导致无限循环的更新,该钩子在服务器渲染期间不被调用.")])]),t._v(" "),a("h3",{attrs:{id:"beforedestroy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforedestroy"}},[t._v("#")]),t._v(" beforeDestroy")]),t._v(" "),a("ul",[a("li",[t._v("实例销毁之前调用.在这一步,实例仍然完全可用.我们可以在这时候进行善后和收尾工作,比如清除定时器.")])]),t._v(" "),a("h3",{attrs:{id:"destroyed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#destroyed"}},[t._v("#")]),t._v(" destroyed")]),t._v(" "),a("ul",[a("li",[t._v("Vue实例销毁后调用.调用后,Vue实例指示的所有东西都会解绑定,所有事件监听器会被移除,所有的子实例也会被销毁.该钩子在服务器端渲染期间不被调用.")])]),t._v(" "),a("h3",{attrs:{id:"activated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#activated"}},[t._v("#")]),t._v(" activated")]),t._v(" "),a("ul",[a("li",[t._v("keep-alive 专属,组件被激活时调用")])]),t._v(" "),a("h3",{attrs:{id:"deactivated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deactivated"}},[t._v("#")]),t._v(" deactivated")]),t._v(" "),a("ul",[a("li",[t._v("keep-alive 专属,组件被销毁时调用")])]),t._v(" "),a("blockquote",[a("p",[t._v("异步请求在哪一步发起?")])]),t._v(" "),a("p",[t._v("可以在钩子函数create、beforeMount,mounted、中进行异步请求,因为在这三个钩子函数中,data已经创建,可以讲服务端返回的数据进行赋值.")]),t._v(" "),a("p",[t._v("如果异步请求不需要依赖DOM推荐在created钩子函数中调用异步请求,因为在created钩子函数中调用异步请求有以下优点:")]),t._v(" "),a("ul",[a("li",[t._v("能更快的获取到服务端的数据,减少页面loading事件;")]),t._v(" "),a("li",[t._v("ssr(服务端渲染)不支持beforeMount,mounted钩子函数,所以放在created中有助于一致性;")])]),t._v(" "),a("h2",{attrs:{id:"vue路由hash模式和history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue路由hash模式和history模式"}},[t._v("#")]),t._v(" Vue路由hash模式和history模式")]),t._v(" "),a("h3",{attrs:{id:"hash模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash模式"}},[t._v("#")]),t._v(" "),a("code",[t._v("hash")]),t._v("模式")]),t._v(" "),a("p",[t._v("早期的前端路由实现就是基于localhost.hash来实现的,其实现原理很简单,localhost.hash的值就是URL中#后面的内容.比如"),a("code",[t._v("https://www.baidu.com#search")]),t._v(",它的localhost.hash的值为‘#search’")]),t._v(" "),a("p",[t._v("hash路由模式的实现主要是基于下面几个特性")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("URL")]),t._v("中"),a("code",[t._v("hash")]),t._v("值只是客户端的一种状态,也就是说当向服务器端发出请求时,"),a("code",[t._v("hash")]),t._v("部分不会被发送;")]),t._v(" "),a("li",[a("code",[t._v("hash")]),t._v("值的改变,都会在浏览器的访问历史中增加一个记录.因此我们能通过浏览器的回退、前进按钮控制"),a("code",[t._v("hash")]),t._v("的切换;")]),t._v(" "),a("li",[t._v("可以通过"),a("code",[t._v("a")]),t._v("标签,并设置"),a("code",[t._v("href")]),t._v("属性,当用户点击这个标签后,"),a("code",[t._v("URL")]),t._v("的"),a("code",[t._v("hash")]),t._v("值后发生改变;或者使用javascript来对localhost.hash进行赋值,改变URL的hash值;")]),t._v(" "),a("li",[t._v("我们可以使用hashchange事件来坚挺hash的变化.从而对页面进行跳转(渲染)")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hashchange'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("funcRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("每一次改变hash(window.localhost.hash),都会在浏览器的访问历史中增加一个记录利用hash的以上特点,就可以来实现前端路由’更新视图但不重新请求页面‘的功能了;")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("特点 : 兼容性好但不美观;")])]),a("hr"),t._v(" "),a("h3",{attrs:{id:"history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history模式"}},[t._v("#")]),t._v(" "),a("code",[t._v("history")]),t._v("模式")]),t._v(" "),a("p",[t._v("history采用HTML5的新特性;且提供了两个方法:"),a("code",[t._v("pushState()")]),t._v(","),a("code",[t._v("repalceState()")]),t._v("可以对浏览器历史记录栈进行修改,以及"),a("code",[t._v("popState()")]),t._v("事件的监听到状态变更")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pushState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nwindow"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("replaceState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("这两个方法有个共同的特点:当调用他们修改浏览器历史记录栈后,虽然当前URL改变了.但浏览器不会刷新页面,这就为单页面应用前端路由‘更新视图但不重新请求页面’提供了基础.")]),t._v(" "),a("p",[t._v("history 路由模式的实现主要基于存在下面几个特性:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("pushState()")]),t._v("和"),a("code",[t._v("replaceState()")]),t._v("两个api来操作实现URL 的变化;")]),t._v(" "),a("li",[t._v("我们可以使用"),a("code",[t._v("popState()")]),t._v("事件来监听URL的变化,从而对页面进行跳转(渲染)")]),t._v(" "),a("li",[t._v("history.pushState()或"),a("code",[t._v("history.replace()")]),t._v("不会触发"),a("code",[t._v("popState")]),t._v("事件,这时我们需要手动触发页面跳转(渲染)")])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("特点: 虽然美观,但是刷新会出现404,需要后端进行配置")])]),a("h2",{attrs:{id:"什么是mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是mvvm"}},[t._v("#")]),t._v(" 什么是MVVM?")]),t._v(" "),a("p",[t._v("Model-View-ViewModel(MVVM)是一个软件架构设计模式,由微软WPF和Silverlight的架构师.....开发,是一种简化用户界面的事件驱动编程方式.由John Gossman()于2005年子啊他的博客上发表")]),t._v(" "),a("p",[t._v("MVVM源自经典的Model-View-Controller(MVC)模式,MVVM的出现促进了前端开发与后端业务逻辑的分离,极大的提高了前端开发效率,MVVM的核心是ViewModel层,它就像是一个中转站,(value Converter),负责转换Model中的数据对象来让数据变得更容易管理和使用,该层向上与视图层进行双向数据绑定,向下与Model层通过接口请求进行数据交互,起承上启下的作用")]),t._v(" "),a("ol",[a("li",[t._v("View层\n"),a("ol",[a("li",[t._v("View 是视图层,也就是用户界面.前端主要是有HTML与CSS来构建.")])])]),t._v(" "),a("li",[t._v("Model层\n"),a("ol",[a("li",[t._v("Model是指数据模型.泛指后端进行各种业务逻辑处理和数据操控,对于前端来说就是后端提供的api接口.")])])]),t._v(" "),a("li",[t._v("ViewModel层\n"),a("ol",[a("li",[t._v("ViewModel 是由前端开发人员组织生成和维护的视图数据层.在这一层,前端开发者对从后端获取的Model数据进行转换处理,做二次封装,以生成View层使用预期的视图数据模型.需要注意的是ViewModel所封装出来的数据模型包括视图的状态和行为两部分,而Model层的数据模型指示包含状态的,比如页面的这一块展示什么,而页面加载进来时发生什么,点击这一块发生什么,这一块滚动时发生什么这些都属于视图行为(交互),视图状态和行为都封装在了ViewModel里.这样的封装使得ViewModel可以完整的去描述View层.")]),t._v(" "),a("li",[t._v("MVVM框架实现了双向绑定,这样ViewModel,的内容会实时展示在View层,前端开发者再也不必低效又麻烦的通过DOM层去更新视图,MVVM框架已经把最脏最累的一块做好了,我们开发者只需要处理和维护ViewModel,更新数据视图就会自动得到相应更新.这样View层展现的不是Model层的数据,而是ViewModel的数据,由ViewModel负责与Model层交互,这样就完全解藕了View和Model层,这个解藕是至关重要的,它是前后端分类方案实施的重要一环.")]),t._v(" "),a("li",[t._v("我们通过一个Vue实例来说明MVVM的具体实现\n"),a("ol",[a("li",[t._v("View层"),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("app"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{{message}}"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-on:")]),t._v("click")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("showMessage()"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Click me"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])])]),t._v(" "),a("li",[t._v("ViewModel层"),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" app "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("el")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#app'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("data")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于描述视图状态   ")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("message")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello Vue!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于描述视图行为  ")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("showMessage")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" vm "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("message"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("created")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" vm "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Ajax 获取 Model 层的数据")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ajax")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("url")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/your/server/data/api'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("success")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n              vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("message "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br")])])]),t._v(" "),a("li",[t._v("Model层"),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"url"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/your/server/data/api"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"res"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"success"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"IoveC"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"domain"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"www.cnblogs.com"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])])])])])])])]),t._v(" "),a("h2",{attrs:{id:"谈谈vue和react组件话的思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈vue和react组件话的思想"}},[t._v("#")]),t._v(" 谈谈Vue和React组件话的思想")]),t._v(" "),a("ul",[a("li",[t._v("我们在各个页面开发的时候,会产生很多重复的功能,比如element中的xxx,像这种纯粹非页面的UI,便成为我们常用的UI组件,最初的前端组件也就仅仅指的是UI组件")]),t._v(" "),a("li",[t._v("随着业务逻辑变的越来越多,我们就想要我们的组件可以处理很多事情,这就是我们常说的组件化,这个组件就不是UI组件,而是包含具体业务的业务组件")]),t._v(" "),a("li",[t._v("这种开发思想就是分而治之.最大程度的降低开发难度和维护成本的效果.并且可以多人协作,每个人写不同的组件,最后像搭积木一样把它构成一个页面")])]),t._v(" "),a("h3",{attrs:{id:"vue-complier-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-complier-实现"}},[t._v("#")]),t._v(" Vue Complier 实现")]),t._v(" "),a("ul",[a("li",[t._v("模版解析这种事,本质是将数据转化为一段html,最开始出现在后端,经过各种处理吐给前端.随着各种"),a("code",[t._v("MV*")]),t._v("的兴起,模版解析交由前端处理.")]),t._v(" "),a("li",[t._v("总的来说,Vue Complier 是将template转换成一个render 字符串.")])]),t._v(" "),a("blockquote",[a("p",[t._v("可以简单理解为以下步骤")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("parse")]),t._v("过程,将"),a("code",[t._v("templat")]),t._v("利用正则转换成"),a("code",[t._v("AST")]),t._v("语法树.")]),t._v(" "),a("li",[a("code",[t._v("optimise")]),t._v("过程,标记静态节点,后"),a("code",[t._v("diff")]),t._v("过程跳过静态节点,提升性能.")]),t._v(" "),a("li",[a("code",[t._v("generate")]),t._v("过程,生成"),a("code",[t._v("render")]),t._v("字符串.")])]),t._v(" "),a("h3",{attrs:{id:"vue3-watch、watcheffect区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-watch、watcheffect区别"}},[t._v("#")]),t._v(" Vue3 Watch、watchEffect区别")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("watch")]),t._v("是惰性执行,也就是只有监听的值发生变化的时候才会执行,但是watchEffect不同,每次代码加载watchEffect都会执行(忽略watch第三个参数的配置,如果修改配置项也可以实现立即执行)")]),t._v(" "),a("li",[t._v("watch需要船体监听的对象,watchEffect不需要")]),t._v(" "),a("li",[t._v("watch智能监听响应式数据:ref定义的属性和reactive定义的对象,如果直接监听reactive定义对象中的属性是不允许的(会报警告),除非使用函数转换一下.其实官网上说的监听一个getter")]),t._v(" "),a("li",[t._v("watchEffect如果监听reactive定义的对象时不起作用的,只能监听对象中的属性.")])]),t._v(" "),a("blockquote",[a("p",[t._v("看一下watchEffect的代码")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("```js\n\n```\n")])])]),a("p",[t._v("总结:")]),t._v(" "),a("ul",[a("li",[t._v("如果定义了reactive的数据,想去使用watch监听数据改变,则无法正确获取旧值,并且deep属性配置无效,自动强制开启了深层监听.")]),t._v(" "),a("li",[t._v("如果使用ref初始化一个对象或者数组类型的数据,会被自动转成reacitve的实现方式,生成proxy代理对象.也会变得无法正确取旧值.")]),t._v(" "),a("li",[t._v("用任何方式生成的数据,如果接受的变量时一个pxory代理对象,就会导致watch回调无法正确获取旧值.")]),t._v(" "),a("li",[t._v("所以当大家使用watch监听对象时,如果在不需要使用旧值的情况,可以正常监听对象没关系;但是如果当监听改变函数里面需要用到的旧值时,只能监听对象.xx属性的方式才行\n异同总结;")])])])}),[],!1,null,null,null);a.default=n.exports}}]);